<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos JS</title>
</head>
<body>
    
    <h1>Fundamentos javaScript</h1>
    <p>Hola</p>

    <script>

        console.log('==== VARIABLES ====')
        // Alcance global (mala practica)
        var hola = 'Hola mundo';

        // Alcance local
        let hello = 'hello world';
        console.log(hola);

        // == Porqué NO usar var ==
        var music = 'Rock';
        console.log(`Variable musica ANTES del bloque ${music}`);

        {
            var music = 'Pop';
            console.log(`Variable musica DENTRO del bloque ${music}`);
        }

        console.log(`Variable musica DESPUÉS del bloque ${music}`);

        // [imprime] lo cual no debería pasar
        //  Rock
        //  Pop
        //  Pop

        // Si declaro con var la variable se queda guardada en el objeto window

        // == Porqué USAR let ==

        console.log('******');
        let music2 = 'Rock';
        console.log(`Variable musica ANTES del bloque ${music2}`);

        {
            let music2 = 'Pop';
            console.log(`Variable musica DENTRO del bloque ${music2}`);
        }

        console.log(`Variable musica DESPUÉS del bloque ${music2}`);


        // ===== CONST ======
        // Son valores que no deben cambiar
        // Con valores primitivos presenta error si se cambian

        const PI = 3.1416

        // Con valores compuestos no presenta error
        const objeto = {
            nombre: 'Oscar',
            edad: 34,
        }
        const colores = ['blanco', 'negro', 'azul'];

        console.log(objeto);
        console.log(colores);

        // Agregando correo al objeto
        objeto.correo = '1@1.com';

        //Pusheando nuevo elemento al array colores
        colores.push('naranja');

        console.log(objeto);
        console.log(colores);

        // ***** Valores primitivos ******

        console.log('==== TIPOS DE DATOS ====')

        // ===== STRINGS ======
        let nombre = '   Oscar';
        let nickname = 'Pollo';

        console.log(nombre, nickname);
        console.log(nombre.length); 
        nickname.length,
        nombre.toLowerCase(),
        nickname.toUpperCase(),
        nombre.includes('sc'), //true
        // El includes busca coincidencias que estén en el string
        
        nombre.trim(); //= Oscar
        // El trim borra espacios antes y después de la cadena

        nombre.split(' '),
        // Split separa las cadenas, en este caso por espacios

        console.log('==== CONCATENACIÓN ====')
        // ===== CONCATENACIÓN ======
        let nombre2 = 'Oscar';
        let apellido = 'Gonzalez';

        let saludo1 = 'Hola mi nombre es ' + nombre2;
        console.log(saludo1);

        // ===== INTERPOLACIÓN ======
        let saludo = `Hola mi nombre es ${nombre2} ${apellido} y me dicen ${nickname}`;
        console.log(saludo);

        let ul = `<ul>
            <li>Lista</li>
            <li>Lista</li>
            <li>Lista</li>
            <li>Lista</li>
            <li>Lista</li>
            <li>Lista</li>
            <li>Lista</li>
        </ul>`

        console.log(ul)

        // ===== NUMEROS ======
        console.log('==== NÚMEROS ====')

        let a = 2;
        let b = new Number(1);
        let c = 7.19;
        let d = '5.6';

        console.log(a,b);
        console.log(c)
        console.log(c.toFixed(1)); // 7.2 (solo un decimal después del punto)
        // Este redondea los decimales
        console.log(c.toFixed(5));
        console.log(parseInt(c)); // 7
        // parseInt recibe flotantes o strings para convertirlo en entero
        console.log(parseFloat(c));
        // parseFloat lo convierte en numero decimal

        console.log(typeof c, typeof d);
        console.log(a + b); // 3
        console.log(c + parseInt(d));
        // Suma el number más la cadena y lo parsea a entero
        console.log(c + parseFloat(d)); // 12.79
        // Suma el number más la cadena y lo parsea a decimal

        // Que es lo mismo q esto
        console.log(c + Number.parseInt(d));
        console.log(c + Number.parseFloat(d));

    // ===== VALORES BOOLEANOS ======
    console.log('==== BOOLEANOS ====')

        let verdadero = true;
        let falso = false;

        console.log(verdadero, falso);
        console.log(typeof verdadero, typeof falso);

        console.log(Boolean(0)); // false
        console.log(Boolean(-7)); // true
        console.log(Boolean('')); // false
        console.log(Boolean(0)); // false



        // ===== NULL UNDEFINED NaN ======

        // Undefined indica que no se ha asignado un valor a la variable
        let indefinida; // undefined = NO tiene valor
        console.log(indefinida);

        // Null indica la ausencia intencional o accidental de un valor
        let nulo = null; 
        console.log(nulo);

        //NaN Not a Number
        let noEsUnNumero = 'hola' * 3.7;
        console.log(noEsUnNumero); //NaN Not a number

        // ****===== FUNCIONES ======****
        console.log('==== FUNCIONES ====')

        // Función declarada
        function primeraFuncion (){
            console.log('uno')
            console.log('dos')
            console.log('tres')
        }

        // Invocación de función
        primeraFuncion();

        //Funcion que devuelve valor
        function funcionValores (){
            console.log('uno')
            console.log('dos')
            return 'La función a devuelto un valor, pero el return cortó todo'
            console.log('tres')
            //Desde el return ya no se ejecuta nada mas dentro de la funcion
        }

        let valorDeFuncion = funcionValores();

        console.log(valorDeFuncion)
        // Para imprimir el return, debo asignarle la función a una variable,
        // para llamarla luego con un console.log

        // Todo el código después del return se ignora

        function saludar(nombre = 'desconocido', edad = 0){
            // Si al invocar esta funcion no le agrego parametros,
            // por defecto pone estos: nombre = 'desconocido', edad = 0

            console.log(`Hola mi nombre es ${nombre} y tengo ${edad} años`);
        }

        saludar('oscar',37); //Hola mi nombre es Oscar y tengo 37 años
        saludar(); //Hola mi nombre es desconocido y tengo 0 años


        // ======= Funciones declaradas Vs expresadas =======
        funcionDeclarada();
        // Estas funciones js las pone en un scope global, por eso puedo invocarla antes de creala

        function funcionDeclarada(){
            console.log('Esto es una función declarada, puedo invocarla en cualquier momento, incluso antes de crearla');
        }

        // *****=== Funcion expresada / Anonima ===*****
        // A diferencia de las declaradas estas no se pueden invocar antes de crearlas
        const funcionExpresada = function(){
            console.log('Esto es una funcion expresada o anonima, se le ha asignado como valor a una variable')
        }

        funcionExpresada();



        // *****===== ARRAYS ======*****
        console.log('==== ARRAYS ====')

        const array1 = [];
        const array2 = [1,true,'Hola',['A', 'B', 'C']];

        console.log(array1);
        console.log(array2);
        console.log(array2[2]) //Hola

        // Accedo la letra C dentro del array anidado
        console.log(array2[3]) // ['A', 'B', 'C']
        console.log(array2[3][2]) // 'C'

        // Este arreglo repite 12 veces el string Hola
        const e = Array(12).fill('Hola');
        console.log(e) //Las 12 posiciones tienen el mismo valor 'Hola'

        const colores2 = ['amarillo', 'Azul', 'Rojo'];
        console.log(colores) //'amarillo', 'Azul', 'Rojo'

        // push: Ubica el color negro en la ultima posición del array
        colores.push('negro');
        console.log(colores) //'amarillo', 'Azul', 'Rojo', 'negro'

        // pop: Quita el color negro de la ultima posición del array
        colores.pop('negro');
        console.log(colores) //'amarillo', 'Azul', 'Rojo'

        // ==== Método forEach ====
        // Con el for each puedo rellenar elementos con elementos del array
        colores2.forEach(function (el, index){
            console.log(`<li id="${index}">${el}</li>`)
        });
        /* <li id="0">amarillo</li>
        <li id="1">Azul</li>
        <li id="2">Rojo</li> */



        // **** ===== OBJETOS ====== ****
        console.log('==== OBJETOS ====')

        // Dentro de un objeto las variables se llaman atributos
        // Y las funciones se llaman métodos
        const user = {
            //Atributos
            nombre : 'Oscar',
            nickname : 'Pollo',
            edad : 37,
            soltero : false,
            pasatiempos : ['Bici', 'Futbol', 'Cine', 'Skate'],
            // Puedo meter objetos dentro de objetos
            contacto : {
                tel : 319,
                mail : '1@1.com',
                twitter : 'my@twitter'
            },

            //Metodos
            saludar : function (){
                console.log('Hola a todos :)');
            },

            decirNombre : function(user = 'User'){
                console.log(`Hola ${user}, mi nombre es ${this.nombre} y me dicen ${this.nickname} y me puedes llamr al ${this.contacto.tel}`)
            }
            //El this hace referencia al objeto en cuestion this.nombre = oscar
        }

        console.log(user);
        console.log(user.nombre); // Oscar
        console.log(user.pasatiempos[0]); //Bici
        console.log(user.contacto.mail);
        user.saludar(); // Hola a todos :)

        user.decirNombre('Marce'); 

        //Este console me imprime las llaves
        console.log(Object.keys(user)); //['nombre', 'nickname', 'edad', 'soltero', 'pasatiempos', 'contacto', 'saludar', 'decirNombre']
        
        //Este console me imprime los valores
        console.log(Object.values(user)); //['Oscar', 'Pollo', 37, false, Array(4), {…}, ƒ, ƒ]

        // este me permite saber si el objeto tiene la propiedad nombre
        console.log(user.hasOwnProperty('nombre')); // true
        console.log(user.hasOwnProperty('nacimiento')); // false



        // **** ==== Operadores ==== ****
        console.log('==== OPERADORES ====')

        // Aritmeticos
        let operadores1 = 5 + (5-10) * 3; // 10
        let moduloPar = 10%2; // 0
        let moduloImpar = 5%2; // 1
        // Si el módulo % de una división entre 2 da cero, significa que es par

        console.log( `el resultado es  ${operadores1}`);
        console.log(`el módulo es  ${modulo}`);

        // Relacionales
        // < > >= <= == === != !===

        console.log(9>8); //true 
        console.log(7>7); //false
        console.log(7>=7); //(operador compuesto) true porque 7 si es igual a 7
        console.log(9>=8); //(operador compuesto) true porque 9 si es mayor a 8

        /* = es asignación de variable
        == Comparación de valores
        === Comparación de tipo de dato y valor
        */

        console.log(7 === 7); //true
        console.log('7' == 7); //true porque por doble igual si es lo mismo
        console.log('7' === 7); //false porque string ≠ number
        console.log(0 === false); //false porque ambos tienden a falso, pero number ≠ boolean

        // Siempre es mejor comparar con triple igual ===

        // ==== Operadores de Incremento / Decremento ====
        let i = 1;

        i += 2 // i = i + 2
        console.log(`El valor de i es ${i}`) //3
        //Estoy sumando el valor que ya tiene i más 2

        let divi = 10;
        divi /= 2 //divi = divi / 2
        console.log(`El valor de d es ${divi}`); //5
        // estoy dividiendo el valor que ya tiene divi entre 2

        // Operador unario
        let j = 2;
        j++; //3
        j--; //2
        console.log(`Console.log después del i++ ${i}`)
        // Se recomienda siempre usar los operadores antes de la variable ( i++ )


        // *** === Operadores lógicos === ***
        // ! not Niega lo que es true, lo vuelve false y viceversa
        // || or Almenos una condición de 2 o más se debe cumplir
        // && and Todas las condiciones se deben cumplir

        console.log(!true); //false

        // con OR almenos una de las condiciones se debe cumplir
        console.log((9 === 9)||( 9 === '9' )); //true

        // con And todas las condiciones se deben cumplir
        console.log((9 === 9) && ( 9 === '9' )); //false



        // **** ==== Estructuras de control ==== **** 
        // Hay estructuras secuenciales que son como las que hemos visto hasta aquí
        // Estructuras condicionales: tomar decisiones, o no, dependiendo de ciertas condiciones
        // Loops Estructuras repetitivas

        console.log('==== Estructuras de control ====')

        //if else
        let edad = 12;
        if (edad >= 18 ){
            console.log('Eres mayor de edad');
        }else{
            console.log('Eres menor de edad');
        }
        // Si dejo solo el < estoy excluyendo el numero contra el que comparto
        // Si dejo <= lo incluyo
        
        //=== if - else if - else===
        // Buenos días 6hrs - 11hrs
        // buenas tardes 12hrs - 18hrs
        // buenas noches 19hrs - 23hrs
        // Deja dormir 24hrs - 5hrs
        let hora = 10;
        if (hora >= 0 && hora <= 5){
            console.log('Dejame dormir')
        } else if (hora >= 6 && hora <= 11){
            console.log('Buenos días')
        } else if (hora >= 12 && hora <= 18){
            console.log('Buenas tardes')
        } else {
            console.log('Buenas noches')
        }

        console.log('==Operador ternario==');
        // Este me permite declarar el if else con otra sintaxis (Solo 2 opciones)
        let eresMayor = (edad >= 18) // Lo defino como variable
        ? 'Eres mayor' //Parte verdadera
        : 'Eres menor'; //Parte verdadera
        console.log(eresMayor); //imprimiendo la variable

        //Se puede en una sola linea
        (5 > 4) ?'Si test' : 'Noooo'; //Si test

        console.log('== SWITCH CASE ==')
        /* 
        domingo 0
        lunes 1
        martes 2
        miercoles 3
        jueves 4
        viernes 5
        sabado 6 
        */
       let dia = 20;
        switch (dia){
            case 0:
                console.log('Domingo');
            break;
            case 1:
                console.log('Lunes');
            break;
            case 2:
                console.log('Martes');
            break;
            case 3:
                console.log('Miercoles');
            break;
            case 4:
                console.log('Jueves');
            break;
            case 5:
                console.log('Viernes');
            break;
            case 6:
                console.log('Sabado');
            break;
            default:
                console.log('El día no existe');
            break;
        }

        let day = 'Martes';
        switch (day){
            case 'Lunes':
                console.log('Wrap de atún');
                break;
            case 'Martes':
                console.log('Sudado de pollo');
                break;
            case 'Miercoles':
                console.log('Verduras con cerdo');
                break;
            default:
                console.log('Domicilio');
                break;
        }
        
    // ===== CICLOS ======
    console.log('==== CICLOS ====');
    // == While ==
    let contador = 0;
    while (contador < 10){
        // A estas estructuras es necesario incluirles un aumento o decremento
        console.log( 'while ' + contador)
        contador++;
    }
    console.log(`Acá contador vale ${contador}`)
 

    // Do while
    do{
        console.log(contador);
        contador++;
    }while(contador < 10);
    // En este se ejecuta al menos una vez 

    // === Ciclo For ===
    console.log('==== CICLO FOR ====');

    for (let i = 0; i < 10; i++){
        console.log('For ' + i);
    }

    let numeros2 = [10,20,30,40,50,60,70,80,90,100];

    for(let i = 0; i < numeros2.length; i++){
        console.log(numeros2[i]);
    }

    console.log('==== CICLO IN / OF ====');

    // For in = Objetos -
    // For in me permite recorrer key, values o ambos de un objeto
    const user2 = {
        nombre: 'Oscar',
        Apellido: 'Gonzalez',
        edad: 37,
    }

    for(const propiedad in user2){
        console.log(`key: ${propiedad} / value: ${user2[propiedad]}`)
        // Acá si no me sirve la notación de punto, 👆 debe ser de corchetes cuadrados
    }

    //- For of = Arrays o strings
    //For of Me permite recorrer un array o una cadena de texto
    for(const el of numeros2){
        console.log(el);
    }

    let hi = 'hello world';
    for(const caracter of hi){
        console.log(caracter)
    }

    setTimeout(() => {console.log('Tomemos una pausa de 5 segundos')}, 5000 );

    // ===== MANEJO DE ERRORES ======
    console.log('==== MANEJO DE ERRORES ====');

    try {
        console.log('En el try se agrega el código a evaluar')
        noExiste;
        console.log('Segundo mensaje en try, no se ejecuta si hay error')
    } catch (error) {
        console.log('Catch captura los errores en el bloque try, si no hay error no hace nada');
        console.log(error);
    } finally{
        console.log('Finally se ejecuta siempre al final de un try-catch')
    }

    try {
        let numero3 = 'y';
        if (isNaN(numero3)){
            //👆 isNaN me valida que si sea un number
            throw new Error('El caracter introducido no es un número');
        }
        // Antes de ejecutar 👇 la operación del console.log, debo 👆 validar que sea un número
        console.log(numero3 * numero3) // Si hay error esta linea no se ejecuta
    } catch (error) {
        console.warn(`Se produjo el siguiente error ${error}`)
    }

    // ===== BREAK & CONTINUE ======
    console.log('==== BREAK & CONTINUE ====');

    const numeros4 = [1,2,3,4,5,6,7,8,9,0];

    for (let i = 0; i < numeros4.length; i ++){
        if(i === 5){
            break; // 👈 Este break corta el barrido del array en el index 5
        }
        console.log(numeros4[i])
    }
    
    for (let i = 0; i < numeros4.length; i ++){
        if(i === 5){
            continue; // 👈 Este continue se salta la posición 5 del array
        }
        console.log(numeros4[i])
    }
    
    console.log('Imprimiendo solo pares')
    for (let i = 0; i < numeros4.length; i ++){
        if(i%2 === 0){
            continue; // 👈 Este continue se salta la posición 5 del array
        }
        console.log(numeros4[i])
    }

    // ===== DESTRUCTURING ======
    console.log('==== DESTRUCTURING ====');
    // Se usa para traer datos de arrays u objetos de forma más dinámica

    console.log('Sin destructuring')
    let numeros5 = [1,2,3];

    let uno = numeros5[0],
        dos = numeros5[1],
        tres = numeros5[2]
    
    console.log(uno,dos,tres)

    console.log('Con destructuring')
    const[one,two,three] = numeros5;

    console.log(one,two,three);

    const persona = {
        name: 'Oscar',
        lastname: 'Gonzalez',
        age:35,
    }

    const {name, age, lastname} = persona;
    console.log(name, lastname, age);

    // ===== OBJETOS LITERALES ======
    console.log('==== OBJETOS LITERALES ====');

    let nombrePerro = 'kenai';
    let edadPerro = 10;

    const perro = {
        nombrePerro: nombrePerro, // Acá key y value son el mismo y se pueden resumir
        edadPerro: edadPerro,
        ladrar: function () {
            console.log('Guauu !!')
        }
    }

    console.log(perro);
    perro.ladrar();

    console.log('Con objetos literales')
    // Con los objetos literales puedo abreviar la construcción de los objetos
    // si el key y el value son el mismo

    // Así 👇 se abrevia
    const dog = {
        nombrePerro, // solo se pone una vez y la coma
        edadPerro,
        ladrar(){ //Se pone son dos puntos y sin la palabra function
            console.log('Guauuu Guauu !!!')
        }
    }

    console.log(dog);
    dog.ladrar();

    // ===== PARAMETROS REST ======
    console.log('==== PARAMETROS REST ====')
    // Sirven para agregar parámetros a una función que pueden o no ser infinitos

    function sumar (a,b, ...c) {
        let resultado = a + b;

        // Si quiero sumar más parámetros creo un ciclo forEach
        c.forEach(function (n) {
            resultado += n
        }) // Sin importar cuantos sean, los parametros serñan recibidos

        return resultado;
    }
    console.log(sumar(1,2));
    console.log(sumar(1,2,3));
    console.log(sumar(1,2,3,4));
    console.log(sumar(1,2,3,4,5)); // Y así sucesivamente

    // ===== SPREAD OPERATOR ======
    console.log('==== SPREAD OPERATOR ====')
    // Operador de propagación Permite la fusión entre arrays 👉👈 

    const arr1 = [1,2,3,4,5],
        arr2 = [6,7,8,9,0]

        console.log(arr1);
        console.log(arr2);

        // Es muy facil 👇 fusionar los arrays, se anteponen los tres puntos
        const arr3 = [...arr1, ...arr2];

        console.log(arr3)

        // ===== ARRAY FUNCTIONS ======
        console.log('==== ARRAY FUNCTIONS ====')

            //Funcion expresada
            const salu2 = function () {
                console.log('Hola');
            }
            salu2();

            // Las arrow function tienen el return implicito
            // Arrow function Si la función tiene más de 1 linea
            const saludar2 = () => {
                console.log('Holii');
                console.log('Si la función tiene más de 1 linea');
            }
            saludar2();

            const saludar3 = (nombre) => {
                console.log(`Hola ${nombre} cómo estás`)
            }
            saludar3('Oscar');

            // Arrow function Si la función tiene 1 linea
            // Si no recibe parametros si hay que poner los parentesis
            const saludar4 = () => console.log(`Si la función tiene 1 linea`);
            saludar4();

            // Si la función tiene 1 solo parametro se pueden quitar los parametros
            const saludar5 = nombre => console.log(`holiii ${nombre} como estas`)
            saludar5('oscar');

            const sumar2 = (a, b) => a + b;
            console.log(sumar2(4, 7));

            //Si la funcion tiene varias lineas se respeta la estructura base
            const variasLineas = () => {
                console.log('Uno');
                console.log('Dos');
                console.log('Tres');
            }
            variasLineas();

            // Tambien puedo usar las arrow en ciclos forEach
            // Este es un for each con funcion normal
            const numeros6 = [1, 2, 3, 4, 5];

            numeros6.forEach(function (el, index) {
                console.log(`Elemento ${el} está en la posición ${index}`);
            })


            console.log('forEach con arrow function');
            // Este es un forEach con arrow function
            numeros6.forEach((el, index) => console.log(`Elemento ${el} está en la posición ${index}`));

            // Los metodos de los objetos no es recomendable usar arrow function, porque altera el scope apuntando a un contexto global
            const perrito = {
                nombre: 'Kenai',
                ladrar() { // Es mejor usarlas como on¡bjetos literales
                    console.log(this)
                }
            }

            perrito.ladrar() // imprime esto { nombre: 'Kenai', ladrar: ƒ ladrar() }

    // ===== PROTOTIPOS ======
    console.log('==== PROTOTIPOS ====')
/* Clases: Molde o modelo a seguir
Objetos. Instancia de una clase
Atributos: Caracteristica  propiedad del objeto, son variables dentro del objeto
Métodos: Son las acciones que un objeto puede realizar son funciones dentro del objeto */

    // Esto es un objeto normal
    const animal = {
        nombre: 'snoopy',
        sonar(){
            console.log('Hago sonidos porq estoy vivo');
        }
    }

    console.log(animal);

    // Esto es una función constructora
    // Las funciones cnstructoras se escriben en UpperCamelCase
    function AnimalMolde(nombre, genero){
        // Atributos
        this.nombre = nombre;
        this.genero = genero;

        //Metodos los saco del constructor
    }

    /* yo puedo sacar los metodos del prototipo, para que al instanciarlo 
    x veces este método no se repita y solo se llame cuando yo lo 
    quiera traer mejora en rendimiento y memoria en la programacion */
    AnimalMolde.prototype.sonar = function (){
            console.log('Hago ruido porq estoy vivo');
        }
    
    AnimalMolde.prototype.saludar = function (){
            console.log(`Hola mi nombre es ${this.nombre}`);
        }


    // Herencia prototipica
    function Perro(nombre, genero, tamanio) {
        this.super = AnimalMolde;
        this.super(nombre, genero);
        this.tamanio = tamanio;
    }

    // Perro esta heredando de AnimalMolde
    Perro.prototype = new AnimalMolde();
    Perro.prototype.constructor = Perro;

    // Sobreescritura del metodo
    Perro.prototype.sonar = function () {
        console.log('Soy un perro y mi sonido es un ladrido');
    }

    Perro.prototype.ladrar = function () {
        console.log('Guauuu Guauuu !!!')
    }

    //Instanciando al molde
    console.log('Instanciando al AnimalMolde'); 
    const bolt = new Perro ('Bolt', 'macho', 'mediano'); // Con el new Perro llamo la herencia de AnimalMolde Perro
    console.log(bolt); 
    
    const mitens = new AnimalMolde ('Mittens', 'hembra');
    console.log(mitens); 

    // Trayendo los metodos
    bolt.saludar();
    bolt.ladrar();
    mitens.saludar();

    // ===== CLASES Y HERIENCIA ======
    console.log('==== CLASES Y HERIENCIA ====')

    // Así se crea una clase
    class AnimalModel { // Las clases no reciben parámetros
        // Atributos
        constructor(nombre, genero){ // los parametros los reciben en el constructor
            this.nombre = nombre;
            this.genero = genero;
        }
    //Los métodos los escribo como objetos literales
        sonar (){
            console.log('hago ruidos porq estoy vivo');
        }
        saludar (){
            console.log(`Me llamo ${this.nombre}`)
        }
    }
    // Creo la herencia antes de insanciar
    class Dog extends AnimalMolde{ //Con extends, Perro hereda las características de AnimalMolde
        constructor(nombre, genero, tamanio){ 
            super(nombre, genero); // con el metodo "super" se manda llamar al constructor de la clase padre
            this.tamanio = tamanio;
            this.raza = null;
        }
        // Sobreescribiendo los metodos
        sonar(){
            console.log('Soy un perro y ladro');
        }
        ladrar2(){
            console.log('Guauu guauu guauu');
        }

        static queEres(){ //El static hace que no tenga que instanciar la clase
            console.log('Los perros son los mejores animales y mascotas del mundo');
        }

        // Los setters y getters permiten establecer y obtener 
        // el valor de atributos de una clase
        get getRaza(){ // El prefijo set dice que es un metodo obtenedor
            return this.raza;
        }
        
        set setRaza(raza){ // set modifica la propiedad
            this.raza = raza;
        }
    }

    Dog.queEres(); // Instanciando solo el metodo estatico

    // Instanciando 
    const rex = new Dog('Rex', 'Macho', 'grande'),
        kitty = new AnimalModel('Kitty', 'Hembra');

    console.log(rex);
    rex.saludar();
    rex.sonar();
    rex.ladrar2();
    console.log(kitty);
    kitty.saludar();
    kitty.sonar();

    // Aunque les get y set son métodos, se llaman como atributos
    console.log(rex.getRaza);
    rex.setRaza = 'Pastor aleman'; // Acá envío el atributo
    console.log(rex.getRaza);

     // ===== METODOS ESTATICOS ======
     console.log('==== METODOS ESTATICOS ====')
     // Un metodo estatico se puede ejecutar sin tener que instanciar la clase
     //Ver linea 828

    // ===== OBJETO CONSOLE ======
    console.log('==== OBJETO CONSOLE ====')

    console.log(console); // Es un objeto que muestra todas las caracteristicas y metodos del console
    console.error('Esto es un error'); // Muestra mensajes en consola como error
    console.warn('Esto es un aviso');
    console.info('Mensaje informativo'); // muy parecido al log
    console.log('Registro de lo que pasa en la aplicación');

    let name2 = 'Oscar',
        lastname2 = 'Gonzalez',
        age2 = 35;

    console.log(name2, lastname2, age2);
    console.log(`Hola mi nombre es ${name2} ${lastname2} y tengo ${age2} años`); // Interpolación
    console.log(`Hola mi nombre es %s %s y tengo %d años`, name2, lastname2, age2); // Uso de almohadillas %
    console.clear(); // Limpia la consola

    console.log(window);
    console.log(document); // Muestra todo el documento html DOM
    console.dir(document); // Muestra me muestra las propiedades y atributos del DOM
    // Sirve para mostrar documentos como si fueran objetos

    console.groupCollapsed ('Los cursos de @jonmircha en youtube');
    // group trae el grupo desplegado
    // groupCollapsed trae el grupo replegado / colapsado
    console.log('Curso de javascript');
    console.log('Curso de CSS');
    console.log('Curso de PWAs');
    console.log('Curso de Flexbox');
    console.log('Curso de Diseño y programación web');
    console.groupEnd();

    console.clear();

    const numbers = [1,2,3,4,5],
    vocals = ['a', 'e', 'i', 'o', 'u'];

    console.table(numbers); // Imprime una tabala del arreglo u objetos en consola
    console.table(vocals);

    console.table(rex); // Crea una tabla con el objeto rex

    console.time('time test'); // Esta es la bandera inicial de la medición
    const arregloMil = Array(1000) // Esta es otra forma de crear arrays

    for(let i = 0; i < arregloMil.length; i++){
        arregloMil[i] = i;
    }

    console.timeEnd('time test'); // Esta es la bandera final de la medición

    for(let i = 0; i < 10; i ++){
        console.count('Código for'); // Permite registrar el numero de veces que se ejecuta una acción
        console.log(i);
    }

    console.clear();

    let x = 1,
        y = 2,
        pruebaxy = 'X siempre debe ser menor que Y';

    console.assert(x < y, {x,y,pruebaxy}); // dentro del console.asserts hago la validación de di hay error o no
    
    console.clear();
    // ===== OBJETO DATE ======
    console.log('==== OBJETO DATE ====')
    console.log(Date()); // El objeto date me muestra la fecha actual
    let fecha = new Date(); // Así puedo convertir la fecha en variable 

    console.log(fecha);
    console.log(fecha.getDate()); // Día del mes
    console.log(fecha.getDay()); // Día de la semana DLMMJVS - 0123456
    console.log(fecha.getMonth()); // Mes del año
    console.log(fecha.getFullYear()); // Año en curso
    console.log(fecha.getHours()); // Horas
    console.log(fecha.getMinutes()); // Minutos
    console.log(fecha.getSeconds ()); // Segundos
    console.log(fecha.getMilliseconds()); // Milisegundos
    console.log(fecha.toString()); // Fecha como string
    console.log(fecha.toDateString()); // Solo la fecha (sin GTM) en string
    console.log(fecha.toLocaleString()); // Fecha y hora
    console.log(fecha.toLocaleDateString()); // Solo Fecha
    console.log(fecha.toLocaleTimeString()); // Solo hora
    console.log(fecha.getTimezoneOffset()); // Mide minutos de la zona horaria
    console.log(fecha.getUTCDate()); // Mide horas en meridiano de grenwich
    console.log(fecha.getUTCHours()); // Mide horas en meridiano de grenwich
    console.log(Date.now()); // Imprime el time stamp parseado de la fecha

    let cumpleOscar = new Date(1986, 2, 3);
    console.log(cumpleOscar);

    console.clear();
    // ===== OBJETO MATH ======
    console.log('==== OBJETO MATH ====')
    
    console.log(Math);
    console.log(Math.PI); // Están en mayus porq nunca cambian
    console.log(Math.abs(-7.8)); // Devuelve el valor absoluto de un numero es decir abs -7.8 = 7.8
    console.log(Math.ceil(7.8)); // Redondea hacia arriba
    console.log(Math.floor(7.8)); // Redondea hacia abajo
    console.log(Math.round(7.8)); // Redondea hacia el que esté más cerca
    console.log(Math.sqrt(81)); // Raiz cuadrada del parámetro
    console.log(Math.pow(2,5)); // Potencia de, primer parámetro base, segundo exponencia
    console.log(Math.sign(-7.8)); // Si el número es negativo devuelve -1, si es positivo 1 7 si es 0, devuelve 0
    
    console.log(Math.random()); // Da un número aleatorio entre 0 y 1
    console.log(Math.random() * 1000); // puedo convertirlo a decimal
    console.log(Math.round(Math.random() * 1000)); // y quitarle los decimales con round


    console.clear();
    // ===== OPERADORES DE CORTO CIRCUITO ======
    console.log('==== OPERADORES DE CORTO CIRCUITO ====')
    // Permiten agregar un valor por defecto, similar a los parámetros default de las dunciones
    // OR Carga por default el valor de la izquierda cuando el valor de la izquierda en la expresión, es true

    const saludar6 = (nombre3) => {
        nombre3 = nombre3 || 'Desconocido';
        console.log(`Hola ${nombre3}`);
    }
    
    saludar6();
    //Si no le doy un parametro, pone por default del valor de la derecha del OR

    console.log('string' || 'Valor de la derecha'); // Imprime 'string'
    console.log(19 || 'Valor de la derecha'); // Imprime 19
    console.log(true || 'Valor de la derecha'); // Imprime true
    console.log([] || 'Valor de la derecha'); // Imprime un array vacío
    console.log({} || 'Valor de la derecha'); // Imprime un objeto vacío

    console.log(false || 'Valor de la derecha'); // Imprime 'Valor de la derecha'
    console.log(0 || 'Valor de la derecha'); // Imprime 'Valor de la derecha'

    console.log('Cambio por AND')
    // AND Carga por default el valor de la izquierda cuando el valor de la izquierda en la expresión, es false (invierte el OR)
    console.log([] && 'Valor de la derecha'); // Imprime un array vacío
    console.log({} && 'Valor de la derecha'); // Imprime un objeto vacío

    console.log(false && 'Valor de la derecha'); // Imprime 'Valor de la derecha'
    console.log(0 && 'Valor de la derecha'); // Imprime 'Valor de la derecha'

    
    console.clear();
    // ===== ALERT, CONFIRM Y PROMPT ======
    console.log('==== ALERT, CONFIRM Y PROMPT ====')
    
/*     let alerta = alert('Esto es una ALERTA!'),
        confirmacion = confirm('Vas a confirmar la acción'), // Se diferencia del alert porque tiene opciones (ok cancel)
        aviso = prompt('Este permite ingresar un valor, ¿cuál vas a ingresar?'); //Este permite ingresar un valor
 */
        /* console.log(alerta); // Devuelve undefined
        console.log(confirmacion); // Devuelve true o false
        console.log(aviso); // devuelve el mismo valor, Si no le ingresa nada devuelve null */

    // ===== EXPRESIONES REGULARES ======
    console.log('==== EXPRESIONES REGULARES ====')
    // Sirven para validar, por ejemplo:

    let cadena = 'Lorem ipsum dolor sir amet lorem 3'
/*     let expReg = new RegExp('lorem', 'ig'); // Sintaxis 1
        console.log(expReg.test(cadena)); // Este método prueba y devuelve un true o false
        console.log(expReg.exec(cadena)); // Muestra donde encontró la coincidencia */
    
    // Sintaxis 2
    // let expReg2 = /lorem/ig; // // Si dejo el Lorem, la expresión regular buscará coincidencia en la cadena i = ignore g = global
    // let expReg2 = /\d/ig; // si pongo la expresión \d buscará numeros
    // let expReg2 = /[0-9]/ig;  // Valida si hay numeros entre 0 y 9
    let expReg2 = /lorem{1,2}/ig;  // Valida si lorem está repetido de 1 a 2 veces
        console.log(expReg2.test(cadena)); // Este método prueba y devuelve un true o false
        console.log(expReg2.exec(cadena)); // Muestra donde encontró la coincidencia

    console.clear();
    // ===== FUNCIONES ANONIMAS AUTOEJECUTABLES (No funcionó) ======
    console.log('==== FUNCIONES ANONIMAS AUTOEJECUTABLES ====')

    // alert('Hola'); alert es una función y los () indican ejecución
    
    (function () {
        console.log("Mi primer IIFE");
    })();

    console.clear();
    // ===== FUNCIONES ANONIMAS AUTOEJECUTABLES (No funcionó) ======
    console.log('==== FUNCIONES ANONIMAS AUTOEJECUTABLES ====')

    
    </script>
</body>
</html>
